import os
import re
import sqlite3
import pandas as pd
from pathlib import Path
from dotenv import load_dotenv
from PIL import Image
import streamlit as st
from groq import Groq

# Load .env if present (local dev convenience)
load_dotenv()

# --- Paths ---
ROOT = Path(__file__).parent.resolve()
DATA_DIR = ROOT / "data"
DB_CANDIDATES = [DATA_DIR / "sqlite-sakila.db", DATA_DIR / "sakila.db"]
ERD_PATH = DATA_DIR / "SQLite3 Sakila Sample Database ERD.png"

DB_PATH = next((p for p in DB_CANDIDATES if p.exists()), None)
assert DB_PATH is not None, f"Could not find DB at {DB_CANDIDATES}"

# --- API Key & Client ---
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
if not GROQ_API_KEY:
    st.error("GROQ API key not found. Please set it in the environment variables.")
    st.stop()

client = Groq(api_key=GROQ_API_KEY)
MODEL_NAME = "llama3-8b-8192"

# --- Database Helpers ---
def get_connection():
    return sqlite3.connect(DB_PATH)

def list_tables(conn):
    q = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name;"
    return [r[0] for r in conn.execute(q).fetchall()]

def describe_table(conn, table):
    cols = conn.execute(f"PRAGMA table_info({table});").fetchall()
    return [{"name": c[1], "type": c[2], "pk": bool(c[5])} for c in cols]

def schema_summary(max_cols=12):
    with get_connection() as conn:
        tables = list_tables(conn)
        summary = []
        for t in tables:
            cols = describe_table(conn, t)
            col_str = ", ".join([c["name"] for c in cols[:max_cols]])
            if len(cols) > max_cols:
                col_str += ", ..."
            summary.append(f"{t}({col_str})")
        return "\n".join(summary), tables

schema_text, ALL_TABLES = schema_summary()

# --- SQL Helpers ---
SQL_CODE_BLOCK = re.compile(r"```(?:sql)?\s*(.*?)```", re.IGNORECASE | re.DOTALL)

def extract_sql(text: str) -> str:
    """Return only the SQL from an LLM response."""
    m = SQL_CODE_BLOCK.search(text)
    if m:
        sql = m.group(1).strip()
    else:
        sql = text.strip()

    select_pos = re.search(r"\b(SELECT|WITH)\b", sql, re.IGNORECASE)
    if select_pos:
        sql = sql[select_pos.start():]

    if ";" in sql:
        sql = sql.split(";")[0] + ";"
    else:
        sql = sql.rstrip() + ";"

    if not re.match(r"\s*(SELECT|WITH)\b", sql, re.IGNORECASE):
        raise ValueError("Only SELECT queries are allowed.")
    return sql

def run_sql(sql: str) -> pd.DataFrame:
    with get_connection() as conn:
        return pd.read_sql_query(sql, conn)

# --- Groq Helpers ---
def nl_to_sql(question: str, tables_for_context=None, temperature=0.0):
    """Ask Groq to produce valid SQLite SQL ONLY."""
    if tables_for_context is None:
        tables_for_context = ALL_TABLES

    with get_connection() as conn:
        context_lines = []
        for t in tables_for_context:
            cols = describe_table(conn, t)
            col_str = ", ".join([c["name"] for c in cols])
            context_lines.append(f"{t}({col_str})")
        context = "\n".join(context_lines)

    system_msg = (
        "You are an expert SQLite SQL generator for the Sakila database. "
        "Always return ONLY a syntactically correct SQL query for SQLite. "
        "Do not include explanations, comments, markdown, or extra text."
    )

    user_msg = f"""
Database schema (subset):
{context}

Task: Convert the user's question to a single SQL SELECT (or a CTE that ends in a SELECT).
Rules:
- Target is SQLite.
- Use only tables/columns that plausibly exist in the schema above.
- Return ONLY the SQL, no explanations, and end with a semicolon.

Question: {question}
    """.strip()

    resp = client.chat.completions.create(
        model=MODEL_NAME,
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_msg},
        ],
        temperature=temperature,
    )

    raw_text = resp.choices[0].message.content
    sql = extract_sql(raw_text)
    return sql

# --- Streamlit App ---
st.title("Talk to My Database")

# Main Page
if "question_asked" not in st.session_state:
    st.session_state.question_asked = False

if not st.session_state.question_asked:
    st.header("Ask a Question")
    question = st.text_input("Enter your question about the database:")

    # Example Questions
    st.subheader("Example Questions")
    st.markdown("""
    - What are the top 10 movies by rental rate?
    - How many customers are in each country?
    - List all actors with their film count.
    - What is the total revenue generated by each store?
    """)

    if question:
        st.session_state.question_asked = True
        st.session_state.question = question
        st.rerun()
else:
    # Display Results
    question = st.session_state.question
    try:
        # Generate SQL query
        sql_query = nl_to_sql(question)
        st.subheader("Generated SQL Query")
        st.code(sql_query, language="sql")

        # Run SQL query and display results
        df = run_sql(sql_query)
        st.subheader("Query Results")
        st.dataframe(df)

        # Side-by-Side Download Buttons
        col1, col2 = st.columns(2)
        with col1:
            csv_data = df.to_csv(index=False).encode("utf-8")
            st.download_button(
                label="Download Results as CSV",
                data=csv_data,
                file_name="query_results.csv",
                mime="text/csv",
            )
        with col2:
            st.download_button(
                label="Download SQL Query",
                data=sql_query.encode("utf-8"),
                file_name="query.sql",
                mime="text/plain",
            )

        # "Ask More Questions" Button
        if st.button("Ask More Questions"):
            st.session_state.question_asked = False
            st.rerun()

    except Exception as e:
        st.error(f"Error: {e}")

# ERD Diagram Section
st.header("Entity-Relationship Diagram (ERD)")
if ERD_PATH.exists():
    st.image(str(ERD_PATH), caption="ERD Diagram", use_container_width =True)
else:
    st.warning(f"ERD not found at {ERD_PATH}")